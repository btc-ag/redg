/*
 * Copyright 2017 BTC Business Technology AG
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.btc.redg.generator.extractor.nameprovider;

import schemacrawler.schema.Column;
import schemacrawler.schema.ForeignKey;
import schemacrawler.schema.Table;

import java.util.LinkedList;
import java.util.List;
import java.util.Objects;

/**
 * This is a name provider that takes the final name from a list of supplied providers. {@link NameProvider}s can be added to an internal list.
 * When a name should be generated, the list of providers is iterated and the value of the first provider to provide a non-null result will be returned.
 * If every provider returns null, the value generated by a {@link DefaultNameProvider} will be used.
 */
public class MultiProviderNameProvider implements NameProvider {

    private List<NameProvider> providers = new LinkedList<>();
    private final NameProvider fallbackProvider = new DefaultNameProvider();

    private boolean wasUsedBefore = false;

    /**
     * {@inheritDoc}
     */
    @Override
    public String getClassNameForTable(final Table table) {
        this.wasUsedBefore = true;
        for (final NameProvider provider : providers) {
            final String name = provider.getClassNameForTable(table);
            if (Objects.nonNull(name)) {
                return name;
            }
        }
        return this.fallbackProvider.getClassNameForTable(table);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String getMethodNameForColumn(final Column column) {
        this.wasUsedBefore = true;
        for (final NameProvider provider : providers) {
            final String name = provider.getMethodNameForColumn(column);
            if (Objects.nonNull(name)) {
                return name;
            }
        }
        return this.fallbackProvider.getMethodNameForColumn(column);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String getMethodNameForForeignKey(final ForeignKey foreignKey) {
        this.wasUsedBefore = true;
        for (final NameProvider provider : providers) {
            final String name = provider.getMethodNameForForeignKey(foreignKey);
            if (Objects.nonNull(name)) {
                return name;
            }
        }
        return this.fallbackProvider.getMethodNameForForeignKey(foreignKey);
    }

    @Override
    public String getMethodNameForIncomingForeignKey(ForeignKey foreignKey) {
        this.wasUsedBefore = true;
        for (final NameProvider provider : providers) {
            final String name = provider.getMethodNameForIncomingForeignKey(foreignKey);
            if (Objects.nonNull(name)) {
                return name;
            }
        }
        return this.fallbackProvider.getMethodNameForIncomingForeignKey(foreignKey);
    }

    /**
     * Adds a name provider to the beginning of the internal list.
     * @param nameProvider The new name provider
     */
    public void prependProvider(final NameProvider nameProvider) {
        if (this.wasUsedBefore) {
            throw new UnsupportedOperationException("Adding providers after a name has been generated could cause non-deterministic names and is forbidden!");
        }
        this.providers.add(0, nameProvider);
    }

    /**
     * Adds a name provider to the end of the internal list.
     * @param nameProvider The new name provider
     */
    public void appendProvider(final NameProvider nameProvider) {
        if (this.wasUsedBefore) {
            throw new UnsupportedOperationException("Adding providers after a name has been generated could cause non-deterministic names and is forbidden!");
        }
        this.providers.add(nameProvider);
    }
}
