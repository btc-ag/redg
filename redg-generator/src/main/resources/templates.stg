// This is the template for the RedG main class that contains all the addX and existingX methods
mainClass(package, prefix, tables, enableVisualizationSupport) ::= <<
/*
 * This file was generated by RedG.
 * https://btc-ag.github.io/redg
 *       ____           ________
 *      / __ \___  ____/ / ____/
 *     / /_/ / _ \/ __  / / __
 *    / _, _/  __/ /_/ / /_/ /
 *   /_/ |_|\___/\__,_/\____/
 *
 * DO NOT EDIT MANUALLY!
 * Re-run the code generation to reflect database changes.
 */
package <package>;

import com.btc.redg.runtime.*;
<if(enableVisualizationSupport)>
import com.btc.redg.models.*;
import com.btc.redg.runtime.dummy.DummyFactory;
import com.btc.redg.runtime.visualization.*;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.lang.reflect.Method;
import java.util.*;
import java.util.stream.Collectors;
<endif>

/**
 * \<p\>This is the RedG main class. Use it to specify your test data and then insert them into the database.\</p\>
 * \<p\>Use this class to customize the RedG runtime options. Use can use the following methods:\</p\>
 * \<ul\>
 *   \<li\>{@link AbstractRedG#setDefaultValueStrategy(DefaultValueStrategy)} to set the default value strategy\<li\>
 *   \<li\>{@link AbstractRedG#setDummyFactory(DummyFactory)} to set the dummy factory\</li\>
 *   \<li\>{@link AbstractRedG#setPreparedStatementParameterSetter(PreparedStatementParameterSetter)} to set the prepared statement parameter setter\</li\>
 *   \<li\>{@link AbstractRedG#setInsertValuesFormatter(InsertValuesFormatter)} to set the insert values formatter\</li\>
 * \</ul\>
 */
public class <prefix>RedG extends AbstractRedG {

    <tables:tableBuilder()>
    <tables:tableBuilderExisting()>
    <tables:tableBuilderDummy()>

    public static java.util.List\<com.btc.redg.models.TableModel\> getAllTableModels() {
        return java.util.Arrays.asList(
            <tables:{it | <it.className>.getTableModel()};separator=",\n">
        );
    }

    <if(enableVisualizationSupport)>
    public String getVisualizationJson() {
        return VisualizationUtil.getVisualizationJson(this.getEntities(), this.getDummyFactory()::isDummy);
    }
    <else>
    public String getVisualizationJson() {
        throw new UnsupportedOperationException("Visualization support is disabled for this code." +
                "Re-run code generation with active visualization support to use this feature!");
    }
    <endif>
}
>>

tableBuilderExisting(table) ::= <<
/**
 * Creates a new reference to an existing entity of the type {@link <table.className>} in the database and returns it. Do not try to modify it or read
 * values other than the primary key(s).
 *
 * \<table summary="The table model attributes and their values"\>
 *     \<tr\>
 *         \<td\>\<strong\>Attribute\</strong\>\</td\>
 *         \<td\>\<strong\>Value\</strong\>\</td\>
 *     \</tr\>
 *     \<tr\>
 *         \<td\>Table name\</td\>
 *         \<td\><table.sqlName>\</td\>
 *     \</tr\>
 *     \<tr\>
 *         \<td\>Full table name\</td\>
 *         \<td\><table.sqlFullName>\</td\>
 *     \</tr\>
 * \</table\>
 */
<if(table.primaryKeyColumns)>
public <table.className> existing<table.name>(<table.primaryKeyColumns:{it|<it.javaTypeName> <it.name>};separator=", ">) {
    <table.className> obj = new Existing<table.className>(this<if(table.primaryKeyColumns)>, <endif><table.primaryKeyColumns:{it|<it.name>};separator=", ">);
    this.addEntity(obj);
    return obj;
}
<endif>
>>

tableBuilder(table) ::= <<
/**
 * Adds a new entity of the type {@link <table.className>} to the RedG entities and returns it for further modification.
 *
 * \<table summary="The table model attributes and their values"\>
 *     \<tr\>
 *         \<td\>\<strong\>Attribute\</strong\>\</td\>
 *         \<td\>\<strong\>Value\</strong\>\</td\>
 *     \</tr\>
 *     \<tr\>
 *         \<td\>Table name\</td\>
 *         \<td\><table.sqlName>\</td\>
 *     \</tr\>
 *     \<tr\>
 *         \<td\>Full table name\</td\>
 *         \<td\><table.sqlFullName>\</td\>
 *     \</tr\>
 * \</table\>
 */
public <table.className> add<table.name>(<\\>
            <table.explicitAttributes:{it | <it.javaTypeName> <it.name>};separator=", "><\\>
            <if(table.explicitAttributes && table.notNullForeignKeys)>, <endif><table.notNullForeignKeys:{it | <it.javaTypeName> <it.name>};separator=", ">) {
    <table.className> obj = new <table.className>(this<\\>
            <if(table.explicitAttributes)>, <endif><table.explicitAttributes:{it | <it.name>};separator=", "><\\>
            <if(table.notNullForeignKeys)>, <endif><table.notNullForeignKeys:{it | <it.name>};separator=", ">);
    this.addEntity(obj);
    return obj;
}<\n>
>>

tableBuilderDummy(table) ::= <<
/**
 * Adds a new dummy entity of the type {@link <table.className>} to the RedG entities and returns it. Modifying it might have unexpected results depending
 * on your dummy factory.
 *
 * \<table summary="The table model attributes and their values"\>
 *     \<tr\>
 *         \<td\>\<strong\>Attribute\</strong\>\</td\>
 *         \<td\>\<strong\>Value\</strong\>\</td\>
 *     \</tr\>
 *     \<tr\>
 *         \<td\>Table name\</td\>
 *         \<td\><table.sqlName>\</td\>
 *     \</tr\>
 *     \<tr\>
 *         \<td\>Full table name\</td\>
 *         \<td\><table.sqlFullName>\</td\>
 *     \</tr\>
 * \</table\>
 */
public <table.className> dummy<table.name>() {
    return this.getDummyFactory().getDummy(this, <table.className>.class);
}<\n>
>>

// ------------------------------- CLASS FOR EACH TABLE --------------------------------------------------------

tableClass(table, colAndForeignKeys, firstRowComma, secondRowComma, serializedTableModelString, enableVisualizationSupport) ::= <<
/*
 * This file was generated by RedG.
 * https://btc-ag.github.io/redg
 *       ____           ________
 *      / __ \___  ____/ / ____/
 *     / /_/ / _ \/ __  / / __
 *    / _, _/  __/ /_/ / /_/ /
 *   /_/ |_|\___/\__,_/\____/
 *
 * DO NOT EDIT MANUALLY!
 * Re-run the code generation to reflect database changes.
 */
package <table.packageName>;

import java.util.ArrayList;
import java.util.List;

import com.btc.redg.runtime.*;
import com.btc.redg.models.*;

/**
 * \<table summary="The table model attributes and their values"\>
 *     \<tr\>
 *         \<td\>\<strong\>Attribute\</strong\>\</td\>
 *         \<td\>\<strong\>Value\</strong\>\</td\>
 *     \</tr\>
 *     \<tr\>
 *         \<td\>Table name\</td\>
 *         \<td\><table.sqlName>\</td\>
 *     \</tr\>
 *     \<tr\>
 *         \<td\>Full table name\</td\>
 *         \<td\><table.sqlFullName>\</td\>
 *     \</tr\>
 * \</table\>
 */
public class <table.className> implements RedGEntity {

    protected AbstractRedG redG;

    // do not manually make this public and instantiate it directly. Use the RedG Main class
    <table.className>(AbstractRedG redG<\\>
            <if(table.explicitAttributes)>, <endif><table.explicitAttributes:{it | <it.javaTypeName> <it.name>};separator=", "><\\>
            <if(table.notNullForeignKeys)>, <endif><table.notNullForeignKeys:{it | <it.javaTypeName> <it.name>};separator=", ">) {
        this.redG = redG;
        <table.explicitAttributes:{it | this.<it.name> = <it.name>;};separator="\n">
        <if(enableVisualizationSupport)><table.explicitAttributes:{it | this.modifiedFields.add("<it.name>");};separator="/n"><endif>
        <table.notNullForeignKeys:setWithNullCheck()>
        try {
            <table.nonExplicitNonFKAttributes:{it | this.<it.name> = redG.getDefaultValueStrategy().getDefaultValue(getTableModel().getColumnBySQLName("<escape.(it.dbName)>"), <it.javaTypeName>.class);<\n>}>
        } catch (Exception e) {
            throw new RuntimeException("Could not get default value", e);
        }
    }

    <if(table.explicitAttributes)>
    <table.className>(AbstractRedG redG<\\>
           <if(table.notNullForeignKeys)>, <endif><table.notNullForeignKeys:{it | <it.javaTypeName> <it.name>};separator=", ">) {
        // dummy constructor (without explicit attributes)
        try {
            this(
                    redG,
                    <table.explicitAttributes:{it | redG.getDefaultValueStrategy().getDefaultValue(getTableModel().getColumnBySQLName("<escape.(it.dbName)>"), <it.javaTypeName>.class)}; separator=",\n"><if(table.notNullForeignKeys)>,<endif>
                    <table.notNullForeignKeys:{it | <it.name>};separator=",\n">
            );
        } catch (Exception e) {
            throw new RuntimeException("Could not get default value", e);
        }
    }
    <endif>

    <table.className>(int meaningOfLife, AbstractRedG redG) {
        // First parameter exists simply because this constructor needs a different signature from the constructor above if the tables have no NOT NULL FK
        // Only for Existing<table.className> , otherwise NOT NULL constraints cannot be checked and no default values are generated.
        this.redG = redG;
    }

    <table.nonForeignKeyColumns:tableClassAttribute(table.className)>
    <table.nonForeignKeyColumns:convenienceSetters(table.className)>
    <table.nullableForeignKeys:tableClassAttribute(table.className)>
    <table.notNullForeignKeys:tableClassAttribute(table.className)>
    <table.nullableForeignKeys:rawForeignKeyGettersWithNullCheck()>
    <table.notNullForeignKeys:rawForeignKeyGetters()>
    <dependenciesGetter(table)>
    <table.incomingForeignKeys:incomingFKGetter()>
    <table.nullableIncomingForeignKeys:incomingFKAdd(table.className)>
    <joinTableSimplifier(table.joinTableSimplifierData)>

    public String getSQLString() {
        return String.format("INSERT INTO <escape.(table.sqlFullName)> (" +
                        "<table.notNullForeignKeys:foreignKeyInsertColumns();separator=", ">" +
                        <if(table.notNullForeignKeys)><if(table.nullableForeignKeys)>", " +<endif><endif>
                        "<table.nullableForeignKeys:foreignKeyInsertColumns();separator=", ">" +
                        <if(colAndForeignKeys)>", " +<endif>
                        "<table.nonForeignKeyColumns:{c|<escape.(c.dbName)>};separator=", ">" +
                        ") VALUES (" +
                        "<table.notNullForeignKeys:foreignKeyInsertPlaceholder();separator=", ">" +
                        <if(table.notNullForeignKeys)><if(table.nullableForeignKeys)>", " +<endif><endif>
                        "<table.nullableForeignKeys:foreignKeyInsertPlaceholder();separator=", ">" +
                        <if(colAndForeignKeys)>", " +<endif>
                        "<table.nonForeignKeyColumns:{c|%s};separator=", ">)",
                <table.notNullForeignKeys:foreignKeyInsertValues();separator=",\n"><if(firstRowComma)>,<endif>
                <table.nullableForeignKeys:foreignKeyInsertValuesNullable();separator=",\n"><if(secondRowComma)>,<endif>
                <table.nonForeignKeyColumns:columnInsertValues();separator=",\n">
        );
    }

    public String getPreparedStatementString() {
        return "INSERT INTO <escape.(table.sqlFullName)> (" +
                "<table.notNullForeignKeys:foreignKeyInsertColumns();separator=", ">" +
                <if(table.notNullForeignKeys)><if(table.nullableForeignKeys)>", " +<endif><endif>
                "<table.nullableForeignKeys:foreignKeyInsertColumns();separator=", ">" +
                <if(colAndForeignKeys)>", " +<endif>
                "<table.nonForeignKeyColumns:{c|<escape.(c.dbName)>};separator=", ">" +
                ") VALUES (" +
                "<table.notNullForeignKeys:foreignKeyInsertStmtPlaceholder();separator=", ">" +
                <if(table.notNullForeignKeys)><if(table.nullableForeignKeys)>", " +<endif><endif>
                "<table.nullableForeignKeys:foreignKeyInsertStmtPlaceholder();separator=", ">" +
                <if(colAndForeignKeys)>", " +<endif>
                "<table.nonForeignKeyColumns:{c|?};separator=", ">)";
    }

    public Object[] getPreparedStatementValues() {
        return new Object[]{
                <table.notNullForeignKeys:foreignKeyInsertStmtValues();separator=",\n"><if(firstRowComma)>,<endif>
                <table.nullableForeignKeys:foreignKeyInsertStmtValuesNullable();separator=",\n"><if(secondRowComma)>,<endif>
                <table.nonForeignKeyColumns:{c|this.<c.name>()};separator=",\n">
        };
    }

    public AttributeMetaInfo[] getPreparedStatementValuesMetaInfos() {
        return new AttributeMetaInfo[]{
                <table.notNullForeignKeys:foreignKeyInsertValueMetaInfos(true);separator=",\n"><if(firstRowComma)>,<endif>
                <table.nullableForeignKeys:foreignKeyInsertValueMetaInfos(false);separator=",\n"><if(secondRowComma)>,<endif>
                <table.nonForeignKeyColumns:columnInsertValueMetaInfo();separator=",\n">
        };
    }

    <if(serializedTableModelString)>
    private static String serializedTableModel = "<serializedTableModelString>";
    private static TableModel tableModel;

    public static String getSerializedTableModel() {
        return serializedTableModel;
    }

    public static TableModel getTableModel() {
        if (tableModel == null) {
            byte[] data = java.util.Base64.getDecoder().decode(serializedTableModel);
            try {
                java.io.ObjectInputStream ois = new java.io.ObjectInputStream(new java.io.ByteArrayInputStream(data));
                tableModel = (TableModel) ois.readObject();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
        return tableModel;
    }
    <endif>
    <if(enableVisualizationSupport)>
    private java.util.Set\<String\> modifiedFields = new java.util.HashSet\<\>();

    public java.util.Set\<String\> getModifiedFields() {
        return this.modifiedFields;
    }
    <endif>
}
>>

incomingFKGetter(fk) ::= <<
<! TODO This implementation has very bad performance when a large amount of data is being modeled! Change this. !>
public List\<<fk.referencingJavaTypeName><">"> <fk.attributeName>() {
    return this.redG.findEntities(<fk.referencingJavaTypeName>.class, gEntity -> ((<fk.referencingJavaTypeName>) gEntity).<fk.referencingAttributeName>() == this);
}<\n>
>>

incomingFKAdd(fk, className) ::= <<
public <className> add<fk.attributeName; format="cap">(<fk.referencingJavaTypeName>... objects) {
    for (<fk.referencingJavaTypeName> obj : objects) {
        obj.<fk.referencingAttributeName>(this);
    }
    return this;
}<\n>
>>

joinTableSimplifier(joinTableData) ::= <<
<joinTableData.keys:{k|<singleJoinTableSimplifier(k, joinTableData.(k))>};separator="\n">
>>

singleJoinTableSimplifier(k, model) ::= <<
public <k> add<model.name>Relation(<model.methodParams.keys:{k|<k> <model.methodParams.(k)>};separator=", ">) {
    <k> rel = new <k>(this.redG<if(model.constructorParams)>, <endif><model.constructorParams:{p|<p>};separator=", ">);
    this.redG.addEntity(rel);
    return rel;
}
>>

setWithNullCheck(col) ::= <<
if (<col.name> == null) {
    throw new IllegalArgumentException("<col.name> may not be null!");
}
this.<col.name> = <col.name>;<\n><\n>
>>

tableClassAttribute(column, className) ::= <<
private <column.javaTypeName> <column.name>;

/**
<if (column.dbName)>
 * \<table summary="The column model attributes and their values"\>
 *     \<tr\>
 *         \<td\>\<strong\>Attribute\</strong\>\</td\>
 *         \<td\>\<strong\>Value\</strong\>\</td\>
 *     \</tr\>
 *     \<tr\>
 *         \<td\>Table name\</td\>
 *         \<td\><column.dbTableName>\</td\>
 *     \</tr\>
 *     \<tr\>
 *         \<td\>Full table name\</td\>
 *         \<td\><column.dbFullTableName>\</td\>
 *     \</tr\>
 *     \<tr\>
 *         \<td\>Column name\</td\>
 *         \<td\><column.dbName>\</td\>
 *     \</tr\>
 *     \<tr\>
 *         \<td\>SQL type\</td\>
 *         \<td\><column.sqlType>\</td\>
 *     \</tr\>
 *     \<tr\>
 *         \<td\>Not nullable?\</td\>
 *         \<td\><column.notNull>\</td\>
 *     \</tr\>
 *     \<tr\>
 *         \<td\>Part of Primary key?\</td\>
 *         \<td\><column.partOfPrimaryKey>\</td\>
 *     \</tr\>
 *     \<tr\>
 *         \<td\>Unique?\</td\>
 *         \<td\><column.unique>\</td\>
 *     \</tr\>
 * \</table\>
<else>
 * This is a foreign key referencing {@link <column.javaTypeName>}
<endif>
 */
public <className> <column.name>(<column.javaTypeName> value) {
    <if(column.notNull && !column.primitiveType)>
    if (value == null) {
        throw new IllegalArgumentException("Setting <column.name> to null violates a NOT NULL constraint!");
    }
    <endif>
    this.<column.name> = value;
    <if(enableVisualizationSupport)>this.modifiedFields.add("<column.name>");<endif>
    return this;
}

/**
<if (column.dbName)>
 * \<table summary="The column model attributes and their values"\>
 *     \<tr\>
 *         \<td\>\<strong\>Attribute\</strong\>\</td\>
 *         \<td\>\<strong\>Value\</strong\>\</td\>
 *     \</tr\>
 *     \<tr\>
 *         \<td\>Table name\</td\>
 *         \<td\><column.dbTableName>\</td\>
 *     \</tr\>
 *     \<tr\>
 *         \<td\>Full table name\</td\>
 *         \<td\><column.dbFullTableName>\</td\>
 *     \</tr\>
 *     \<tr\>
 *         \<td\>Column name\</td\>
 *         \<td\><column.dbName>\</td\>
 *     \</tr\>
 *     \<tr\>
 *         \<td\>SQL type\</td\>
 *         \<td\><column.sqlType>\</td\>
 *     \</tr\>
 *     \<tr\>
 *         \<td\>Not nullable?\</td\>
 *         \<td\><column.notNull>\</td\>
 *     \</tr\>
 *     \<tr\>
 *         \<td\>Part of Primary key?\</td\>
 *         \<td\><column.partOfPrimaryKey>\</td\>
 *     \</tr\>
 *     \<tr\>
 *         \<td\>Unique?\</td\>
 *         \<td\><column.unique>\</td\>
 *     \</tr\>
 * \</table\>
<else>
 * This is a foreign key referencing {@link <column.javaTypeName>}
<endif>
 */
public <column.javaTypeName> <column.name>() {
    return this.<column.name>;
}
<\n>
>>

convenienceSetters(column, className) ::= <<
<column.convenienceSetters:convenienceSetter(column, className)>
>>

convenienceSetter(convenienceSetter, column, className) ::= <<
/**
<if (column.dbName)>
 * \<table summary="The column model attributes and their values"\>
 *     \<tr\>
 *         \<td\>\<strong\>Attribute\</strong\>\</td\>
 *         \<td\>\<strong\>Value\</strong\>\</td\>
 *     \</tr\>
 *     \<tr\>
 *         \<td\>Table name\</td\>
 *         \<td\><column.dbTableName>\</td\>
 *     \</tr\>
 *     \<tr\>
 *         \<td\>Full table name\</td\>
 *         \<td\><column.dbFullTableName>\</td\>
 *     \</tr\>
 *     \<tr\>
 *         \<td\>Column name\</td\>
 *         \<td\><column.dbName>\</td\>
 *     \</tr\>
 *     \<tr\>
 *         \<td\>SQL type\</td\>
 *         \<td\><column.sqlType>\</td\>
 *     \</tr\>
 *     \<tr\>
 *         \<td\>Not nullable?\</td\>
 *         \<td\><column.notNull>\</td\>
 *     \</tr\>
 *     \<tr\>
 *         \<td\>Part of Primary key?\</td\>
 *         \<td\><column.partOfPrimaryKey>\</td\>
 *     \</tr\>
 *     \<tr\>
 *         \<td\>Unique?\</td\>
 *         \<td\><column.unique>\</td\>
 *     \</tr\>
 * \</table\>
<else>
 * This is a foreign key referencing {@link <column.javaTypeName>}
<endif>
 */
public <className> <column.name>(<convenienceSetter.setterJavaTypeName> value) {
    <if(column.notNull && !convenienceSetter.primitiveType)>
    if (value == null) {
        throw new IllegalArgumentException("Setting <column.name> to null violates a NOT NULL constraint!");
    }
    <endif>
    this.<column.name> = <convenienceSetter.fullyQualifiedConverterMethodName>(value, <column.javaTypeName>.class);
    <if(enableVisualizationSupport)>this.modifiedFields.add("<column.name>");<endif>
    return this;
}
<\n>
>>

foreignKeyInsertColumns(foreignKey) ::= <<
<foreignKey.references.keys:{k|<k>};separator=", ">
>>

foreignKeyInsertPlaceholder(foreignKey) ::= <<
<foreignKey.references.keys:{k|%s};separator=", ">
>>

foreignKeyInsertStmtPlaceholder(foreignKey) ::= <<
<foreignKey.references.keys:{k|?};separator=", ">
>>

foreignKeyInsertValues(foreignKey) ::= <<
<foreignKey.references.keys:{k|this.redG.getSqlValuesFormatter().formatValue(this.<foreignKey.name>.<foreignKey.references.(k).primaryKeyAttributeName>(),
        "<foreignKey.references.(k).sqlType>", "<escape.(foreignKey.references.(k).dbFullTableName)>",
        "<escape.(foreignKey.references.(k).dbTableName)>", "<escape.(foreignKey.references.(k).dbName)>")};separator=",\n">
>>

foreignKeyInsertValuesNullable(foreignKey) ::= <<
<foreignKey.references.keys:{k|this.redG.getSqlValuesFormatter().formatValue((this.<foreignKey.name> != null) ? this.<foreignKey.name>.<foreignKey.references.(k).primaryKeyAttributeName>() : null,
        "<foreignKey.references.(k).sqlType>", "<escape.(foreignKey.references.(k).dbFullTableName)>",
        "<escape.(foreignKey.references.(k).dbTableName)>", "<escape.(foreignKey.references.(k).dbName)>")};separator=",\n">
>>

foreignKeyInsertStmtValues(foreignKey) ::= <<
<foreignKey.references.keys:{k|this.<foreignKey.name>.<foreignKey.references.(k).primaryKeyAttributeName>()};separator=",\n">
>>

foreignKeyInsertStmtValuesNullable(foreignKey) ::= <<
<foreignKey.references.keys:{k|(this.<foreignKey.name> != null) ? this.<foreignKey.name>.<foreignKey.references.(k).primaryKeyAttributeName>() : null};separator=",\n">
>>

foreignKeyInsertValueMetaInfos(foreignKey, notNull) ::= <<
<foreignKey.references.keys:{k|new AttributeMetaInfo("<escape.(foreignKey.references.(k).dbName)>", "<escape.(foreignKey.references.(k).dbTableName)>", "<escape.(foreignKey.references.(k).dbFullTableName)>", "<foreignKey.references.(k).sqlType>", <foreignKey.references.(k).sqlTypeInt>, <foreignKey.references.(k).localType>.class, <notNull>)};separator=",\n">
>>

columnInsertValueMetaInfo(column) ::= <<
new AttributeMetaInfo("<escape.(column.dbName)>", "<escape.(column.dbTableName)>", "<escape.(column.dbTableName)>", "<column.sqlType>", <column.sqlTypeInt>, <column.javaTypeName>.class, <column.notNull>)
>>

columnInsertValues(column) ::= <<
this.redG.getSqlValuesFormatter().formatValue(this.<column.name>(),
        "<column.sqlType>", "<escape.(column.dbFullTableName)>",
        "<escape.(column.dbTableName)>", "<escape.(column.dbName)>")
>>

rawForeignKeyGetters(fKey) ::= <<
<fKey.references.keys:{k|<rawForeignKeyGetter(fKey.references.(k), fKey.name)>}>
>>

rawForeignKeyGettersWithNullCheck(fKey) ::= <<
<fKey.references.keys:{k|<rawForeignKeyGetterWithNullCheck(fKey.references.(k), fKey.name)>}>
>>

dependenciesGetter(table) ::= <<
public List\<RedGEntity> getDependencies() {
    List\<RedGEntity> dependencies = new ArrayList\<>();
    <table.foreignKeys:{fk|if (<fk.name> != null) dependencies.add(<fk.name>);};separator="\n">
    return dependencies;
}<\n>
>>

rawForeignKeyGetter(ref, varName) ::= <<
/**
 * \<table summary="The column model attributes and their values"\>
 *     \<tr\>
 *         \<td\>\<strong\>Attribute\</strong\>\</td\>
 *         \<td\>\<strong\>Value\</strong\>\</td\>
 *     \</tr\>
 *     \<tr\>
 *         \<td\>Table name\</td\>
 *         \<td\><ref.dbTableName>\</td\>
 *     \</tr\>
 *     \<tr\>
 *         \<td\>Full table name\</td\>
 *         \<td\><ref.dbFullTableName>\</td\>
 *     \</tr\>
 *     \<tr\>
 *         \<td\>Column name\</td\>
 *         \<td\><ref.dbName>\</td\>
 *     \</tr\>
 *     \<tr\>
 *         \<td\>SQL type\</td\>
 *         \<td\><ref.sqlType>\</td\>
 *     \</tr\>
 * \</table\>
 */
public <ref.localType> <ref.localName>() {
    return this.<varName>.<ref.primaryKeyAttributeName>();
}<\n>
>>

rawForeignKeyGetterWithNullCheck(ref, varName) ::= <<
public <ref.localType> <ref.localName>() {
    if (this.<varName> != null) {
        return this.<varName>.<ref.primaryKeyAttributeName>();
    }
    return null;
}<\n>
>>

// ------------------------------- CLASS FOR EACH TABLE (EXISTING ENTRIES) --------------------------------------------------------

existingTableClass(table) ::= <<
/*
 * This file was generated by RedG.
 * https://btc-ag.github.io/redg
 *       ____           ________
 *      / __ \___  ____/ / ____/
 *     / /_/ / _ \/ __  / / __
 *    / _, _/  __/ /_/ / /_/ /
 *   /_/ |_|\___/\__,_/\____/
 *
 * DO NOT EDIT MANUALLY!
 * Re-run the code generation to reflect database changes.
 */
package <table.packageName>;

import com.btc.redg.runtime.*;

/**
 * {@inheritDoc}
 */
public class Existing<table.className> extends <table.className> {

    Existing<table.className>(AbstractRedG redG<if(table.primaryKeyColumns)>, <endif><table.primaryKeyColumns:{it|<it.javaTypeName> <it.name>};separator=", ">) {
        super(42, redG);
        <if (table.primaryKeyColumns)>
        <table.primaryKeyColumns:{it|<if(it.partOfForeignKey)>this.<it.name> = <it.name><else>super.<it.name>(<it.name>)<endif>};separator=";\n">;
        <else>
        throw new UnsupportedOperationException("Cannot reference an existing entity if the table has no primary keys");
        <endif>
    }

    <table.primaryKeyColumns:overrideTableClassAttributesPK(table.className)>
    <table.nonPrimaryKeyNonFKColumns:overrideTableClassAttributes(table.className)>
    <table.nonForeignKeyColumns:overrideConvenienceSetters(table.className)>
    <table.foreignKeys:overrideTableClassAttributes(table.className)>
    <table.foreignKeys:overrideRawForeignKeyGetters()>

    @Override
    public String getSQLString() {
    <if (table.primaryKeyColumns)>
        return String.format("SELECT COUNT(*) FROM <escape.(table.sqlName)> WHERE " +
                        "<table.primaryKeyColumns:{it|<escape.(it.dbName)> = %s};separator=" AND ">",
                <table.primaryKeyColumns:overrideColumnInsertValues();separator=",\n">
        );
    <else>
        return "Your table has no primary key(s), referincing existing entities is not possible!";
    <endif>
    }

    @Override
    public String getPreparedStatementString() {
    <if (table.primaryKeyColumns)>
        return "SELECT COUNT(*) FROM <escape.(table.sqlName)> WHERE " +
                <table.primaryKeyColumns:{it|"<escape.(it.dbName)> = ?};separator=" AND \" +\n">";
    <else>
        return "Your table has no primary key(s), referencing existing entities is not possible!";
    <endif>
    }

    @Override
    public Object[] getPreparedStatementValues() {
        return new Object[] {
                <table.primaryKeyColumns:{c|<if(c.partOfForeignKey)>this.<c.name><else>super.<c.name>()<endif>};separator=",\n">
        };
    }

    @Override
    public AttributeMetaInfo[] getPreparedStatementValuesMetaInfos() {
        return new AttributeMetaInfo[] {
                <table.primaryKeyColumns:columnInsertValueMetaInfo();separator=",\n">
        };
    }
}
>>

overrideTableClassAttributes(column, className) ::= <<
/**
 * {@inheritDoc}
 */
@Override
public <className> <column.name>(<column.javaTypeName> value) {
    throw new UnsupportedOperationException("Cannot change values of entities declared as existing.");
}

/**
 * {@inheritDoc}
 */
@Override
public <column.javaTypeName> <column.name>() {
    throw new UnsupportedOperationException("Cannot read values of entities declared as existing that are not part of the primary key.");
}
<\n>
>>

overrideConvenienceSetters(column, className) ::= <<
<column.convenienceSetters:overrideConvenienceSetter(column, className)>
>>

overrideConvenienceSetter(convenienceSetter, column, className) ::= <<
/**
 * {@inheritDoc}
 */
@Override
public <className> <column.name>(<convenienceSetter.setterJavaTypeName> value) {
    throw new UnsupportedOperationException("Cannot change values of entities declared as existing.");
}
<\n>

>>

overrideTableClassAttributesPK(column, className) ::= <<
<if(!column.partOfForeignKey)>/**
 * {@inheritDoc}
 */
@Override
public <className> <column.name>(<column.javaTypeName> value) {
    throw new UnsupportedOperationException("Cannot change values of entities declared as existing.");
}

/**
 * {@inheritDoc}
 */
@Override
public <column.javaTypeName> <column.name>() {
    return super.<column.name>();
}
<\n><else>
// This is an attribute for a primary key that is a foreign key as well
private <column.javaTypeName> <column.name>;
<endif>
>>

overrideRawForeignKeyGetters(fKey) ::= <<
<fKey.references.keys:{k|<overrideRawForeignKeyGetter(fKey.references.(k), fKey.name)>}>
>>

overrideRawForeignKeyGetter(ref, varName) ::= <<
@Override
public <ref.localType> <ref.localName>() {
    throw new UnsupportedOperationException("Cannot read values of entities declared as existing that are not part of the primary key.");
}<\n>
>>

overrideColumnInsertValues(column) ::= <<
this.redG.getSqlValuesFormatter().formatValue(super.<column.name>(),
        "<column.sqlType>", "<escape.(column.dbTableName)>",
        "<escape.(column.dbTableName)>", "<escape.(column.dbName)>")
>>


